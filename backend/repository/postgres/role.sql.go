// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: role.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignRole = `-- name: AssignRole :one
INSERT INTO account_role (id, account_id, user_role_id, created_at, updated_at)
VALUES ($1, $2, $3, NOW(), NOW())
RETURNING id, account_id, user_role_id, created_at, updated_at, deleted_at
`

type AssignRoleParams struct {
	ID         pgtype.UUID
	AccountID  pgtype.UUID
	UserRoleID pgtype.UUID
}

func (q *Queries) AssignRole(ctx context.Context, arg AssignRoleParams) (AccountRole, error) {
	row := q.db.QueryRow(ctx, assignRole, arg.ID, arg.AccountID, arg.UserRoleID)
	var i AccountRole
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.UserRoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createRole = `-- name: CreateRole :one
INSERT INTO user_role (id, role_title, created_at, updated_at)
VALUES ($1, $2, NOW(), NOW())
RETURNING id, role_title, created_at, updated_at, deleted_at
`

type CreateRoleParams struct {
	ID        pgtype.UUID
	RoleTitle string
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (UserRole, error) {
	row := q.db.QueryRow(ctx, createRole, arg.ID, arg.RoleTitle)
	var i UserRole
	err := row.Scan(
		&i.ID,
		&i.RoleTitle,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteRole = `-- name: DeleteRole :exec
UPDATE user_role
SET
    deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteRole(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteRole, id)
	return err
}

const getRoleByEmail = `-- name: GetRoleByEmail :one
SELECT
    a.id
    , a.email
    , ur.role_title
FROM user_role AS ur
JOIN account_role AS ar
    ON ur.id = ar.user_role_id
JOIN account AS a
    ON ar.account_id = a.id
WHERE a.email = $1
LIMIT 1
`

type GetRoleByEmailRow struct {
	ID        pgtype.UUID
	Email     string
	RoleTitle string
}

func (q *Queries) GetRoleByEmail(ctx context.Context, email string) (GetRoleByEmailRow, error) {
	row := q.db.QueryRow(ctx, getRoleByEmail, email)
	var i GetRoleByEmailRow
	err := row.Scan(&i.ID, &i.Email, &i.RoleTitle)
	return i, err
}

const updateRole = `-- name: UpdateRole :one
UPDATE user_role
SET
    role_title = $1,
    updated_at = NOW()
WHERE id = $2
RETURNING id, role_title, created_at, updated_at, deleted_at
`

type UpdateRoleParams struct {
	RoleTitle string
	ID        pgtype.UUID
}

func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) (UserRole, error) {
	row := q.db.QueryRow(ctx, updateRole, arg.RoleTitle, arg.ID)
	var i UserRole
	err := row.Scan(
		&i.ID,
		&i.RoleTitle,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
